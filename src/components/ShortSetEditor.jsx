import { useState, useEffect } from 'react'
import { jokesAPI } from '../services/api'
import { setsAPI } from '../services/setsAPI'
import './ShortSetEditor.css'

function ShortSetEditor({ onBack, editingSet, onSave }) {
  const [header, setHeader] = useState('')
  const [availableJokes, setAvailableJokes] = useState([])
  const [selectedJokes, setSelectedJokes] = useState([])
  const [transitions, setTransitions] = useState({}) // { jokeId: 'transition text' }
  const [showJokeSelector, setShowJokeSelector] = useState(false)
  const [loading, setLoading] = useState(true)
  const [isDraft, setIsDraft] = useState(true)
  const [hoveredJokeId, setHoveredJokeId] = useState(null)

  useEffect(() => {
    loadJokes()
    if (editingSet) {
      loadSetData(editingSet)
    }
  }, [editingSet])

  const loadSetData = (set) => {
    setHeader(set.header || '')
    setIsDraft(set.isDraft !== undefined ? set.isDraft : true)
    
    // Load jokes
    if (set.jokeDetails && set.jokeDetails.length > 0) {
      setSelectedJokes(set.jokeDetails)
      
      // Load transitions
      const transitionsObj = {}
      if (set.transitions && set.transitions.length > 0) {
        set.jokeDetails.forEach((joke, index) => {
          if (index < set.transitions.length && set.transitions[index]) {
            transitionsObj[joke.id] = set.transitions[index]
          }
        })
      }
      setTransitions(transitionsObj)
    }
  }

  const loadJokes = async () => {
    try {
      setLoading(true)
      const jokes = await jokesAPI.getAll()
      setAvailableJokes(jokes)
    } catch (error) {
      console.error('Error loading jokes:', error)
      alert('Failed to load jokes. Please try again.')
    } finally {
      setLoading(false)
    }
  }

  const handleAddJoke = (joke) => {
    // Check if joke is already added
    if (selectedJokes.find(j => j.id === joke.id)) {
      return
    }
    
    setSelectedJokes([...selectedJokes, joke])
    // Initialize empty transition for this joke
    setTransitions({ ...transitions, [joke.id]: '' })
    setShowJokeSelector(false)
  }

  const handleRemoveJoke = (jokeId) => {
    setSelectedJokes(selectedJokes.filter(j => j.id !== jokeId))
    // Remove transition for this joke
    const newTransitions = { ...transitions }
    delete newTransitions[jokeId]
    setTransitions(newTransitions)
  }

  const handleMoveJoke = (index, direction) => {
    const newJokes = [...selectedJokes]
    if (direction === 'up' && index > 0) {
      [newJokes[index - 1], newJokes[index]] = [newJokes[index], newJokes[index - 1]]
    } else if (direction === 'down' && index < newJokes.length - 1) {
      [newJokes[index], newJokes[index + 1]] = [newJokes[index + 1], newJokes[index]]
    }
    setSelectedJokes(newJokes)
  }

  const handleTransitionChange = (jokeId, value) => {
    setTransitions({ ...transitions, [jokeId]: value })
  }

  const generateSetText = () => {
    const transitionsArray = selectedJokes.map((joke, index) => {
      if (index === selectedJokes.length - 1) {
        return null
      }
      return transitions[joke.id] || ''
    })

    let text = `SET: ${header}\n`
    text += `Type: Short Set (Open Mic)\n`
    text += `Date: ${new Date().toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    })}\n`
    text += `${'='.repeat(60)}\n\n`

    selectedJokes.forEach((joke, index) => {
      text += `JOKE ${index + 1}: ${joke.header || 'Untitled Joke'}\n`
      text += `${'-'.repeat(60)}\n`

      // Add joke sections (context and punchline)
      if (joke.sections && joke.sections.length > 0) {
        joke.sections.forEach((section, sectionIndex) => {
          const sectionLabel = section.type === 'context' ? 'CONTEXT' : 'PUNCHLINE'
          text += `\n[${sectionLabel}]\n`
          text += `${section.text}\n`
        })
      } else {
        // Fallback for old format
        if (joke.context) text += `\n[CONTEXT]\n${joke.context}\n`
        if (joke.punchline) text += `\n[PUNCHLINE]\n${joke.punchline}\n`
      }

      // Add transition if exists
      if (index < transitionsArray.length && transitionsArray[index]) {
        text += `\n[TRANSITION]\n${transitionsArray[index]}\n`
      }

      text += `\n${'='.repeat(60)}\n\n`
    })

    text += `\nTotal Jokes: ${selectedJokes.length}\n`
    text += `Generated by Comedica\n`

    return text
  }

  const downloadSetAsText = () => {
    const text = generateSetText()
    const blob = new Blob([text], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `${header.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_set_${Date.now()}.txt`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  const handleSaveSet = async (saveAsDraft = false) => {
    if (!header.trim()) {
      alert('Please enter a header (bigger idea) for your set')
      return
    }

    if (selectedJokes.length === 0) {
      alert('Please add at least one joke to your set')
      return
    }

    // Build transitions array - transitions[i] is the transition AFTER joke[i]
    const transitionsArray = selectedJokes.map((joke, index) => {
      // Last joke doesn't have a transition after it
      if (index === selectedJokes.length - 1) {
        return null
      }
      return transitions[joke.id] || ''
    })

    try {
      const setData = {
        header,
        type: 'short',
        jokes: selectedJokes.map(j => j.id),
        jokeDetails: selectedJokes,
        transitions: transitionsArray,
        isDraft: saveAsDraft,
        updatedAt: new Date().toISOString()
      }

      if (editingSet) {
        // Update existing set
        await setsAPI.update(editingSet.id, setData)
        alert(saveAsDraft ? '‚úÖ Set updated as draft!' : '‚úÖ Set finalised and updated successfully!')
      } else {
        // Create new set
        setData.id = Date.now().toString()
        setData.createdAt = new Date().toISOString()
        await setsAPI.create(setData)
        alert(saveAsDraft ? '‚úÖ Set saved as draft!' : '‚úÖ Set finalised and saved successfully!')
      }

      // Download text file if finalizing (not saving as draft)
      if (!saveAsDraft) {
        downloadSetAsText()
      }
      
      if (onSave) {
        onSave()
      } else {
        onBack()
      }
    } catch (error) {
      console.error('Error saving set:', error)
      const errorMessage = error.message || 'Unknown error'
      alert(`Failed to save set: ${errorMessage}\n\nIf you see a database error, make sure to run the SQL migration to add the is_draft column.`)
    }
  }

  const renderJokePreview = (joke) => {
    const sections = joke.sections || []
    const contextSections = sections.filter(s => s.type === 'context')
    const punchlineSections = sections.filter(s => s.type === 'punchline')
    
    return (
      <div 
        className="joke-preview-card"
        onMouseEnter={() => setHoveredJokeId(joke.id)}
        onMouseLeave={() => setHoveredJokeId(null)}
        onTouchStart={() => setHoveredJokeId(hoveredJokeId === joke.id ? null : joke.id)}
      >
        <div className="joke-preview-header">
          <h4>{joke.header || 'Untitled Joke'}</h4>
          <span className={`status-badge ${joke.isDraft ? 'draft' : 'final'}`}>
            {joke.isDraft ? 'Draft' : 'Final'}
          </span>
        </div>
        {contextSections.length > 0 && (
          <div className="joke-preview-section">
            <strong>Context:</strong>
            {contextSections.map((ctx, idx) => (
              <p key={ctx.id || idx}>{ctx.text.substring(0, 100)}...</p>
            ))}
          </div>
        )}
        {punchlineSections.length > 0 && (
          <div className="joke-preview-section">
            <strong>Punchline:</strong>
            {punchlineSections.map((pl, idx) => (
              <p key={pl.id || idx}>{pl.text.substring(0, 100)}...</p>
            ))}
          </div>
        )}
        
        {/* Full joke tooltip */}
        {hoveredJokeId === joke.id && (
          <div className="joke-full-tooltip">
            <div className="tooltip-header">
              <h4>{joke.header || 'Untitled Joke'}</h4>
              <button 
                className="tooltip-close"
                onClick={(e) => {
                  e.stopPropagation()
                  setHoveredJokeId(null)
                }}
              >
                √ó
              </button>
            </div>
            <div className="tooltip-content">
              {joke.sections && joke.sections.length > 0 ? (
                joke.sections.map((section, idx) => (
                  <div key={section.id || idx} className={`tooltip-section ${section.type}-section`}>
                    <strong className={`tooltip-label ${section.type}-label`}>
                      {section.type === 'context' ? 'Context' : 'Punchline'}:
                    </strong>
                    <p className="tooltip-text">{section.text}</p>
                  </div>
                ))
              ) : (
                <>
                  {joke.context && (
                    <div className="tooltip-section context-section">
                      <strong className="tooltip-label context-label">Context:</strong>
                      <p className="tooltip-text">{joke.context}</p>
                    </div>
                  )}
                  {joke.punchline && (
                    <div className="tooltip-section punchline-section">
                      <strong className="tooltip-label punchline-label">Punchline:</strong>
                      <p className="tooltip-text">{joke.punchline}</p>
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        )}
      </div>
    )
  }

  return (
    <div className="short-set-editor">
      <div className="editor-header">
        <button className="back-btn" onClick={onBack}>
          ‚Üê Back
        </button>
        <h2>{editingSet ? 'Edit Short Set' : 'Short Set Editor'}</h2>
      </div>

      <div className="editor-body">
        <div className="set-header-section">
          <label className="header-label">
            <span className="label-text">Bigger Idea / Set Header</span>
            <input
              type="text"
              className="set-header-input"
              placeholder="What's the bigger idea behind this set?"
              value={header}
              onChange={(e) => setHeader(e.target.value)}
            />
          </label>
        </div>

        <div className="joke-selection-section">
          <div className="section-header">
            <h3>Selected Jokes ({selectedJokes.length})</h3>
            <button 
              className="add-joke-btn"
              onClick={() => setShowJokeSelector(!showJokeSelector)}
            >
              + Add Joke
            </button>
          </div>

          {showJokeSelector && (
            <div className="joke-selector">
              <div className="selector-header">
                <h4>Select a Joke to Add</h4>
                <button 
                  className="close-selector"
                  onClick={() => setShowJokeSelector(false)}
                >
                  √ó
                </button>
              </div>
              {loading ? (
                <p>Loading jokes...</p>
              ) : availableJokes.length === 0 ? (
                <p>No jokes available. Create some jokes first!</p>
              ) : (
                <div className="available-jokes-list">
                  {availableJokes
                    .filter(joke => !selectedJokes.find(j => j.id === joke.id))
                    .map(joke => (
                      <div 
                        key={joke.id} 
                        className="available-joke-item simple"
                        onClick={() => handleAddJoke(joke)}
                      >
                        <div className="joke-header-only">
                          <h4>{joke.header || 'Untitled Joke'}</h4>
                          <span className={`status-badge-small ${joke.isDraft ? 'draft' : 'final'}`}>
                            {joke.isDraft ? 'Draft' : 'Final'}
                          </span>
                        </div>
                      </div>
                    ))}
                </div>
              )}
            </div>
          )}

          {selectedJokes.length === 0 ? (
            <div className="empty-state">
              <p>No jokes added yet. Click "+ Add Joke" to get started!</p>
            </div>
          ) : (
            <div className="selected-jokes-list">
              {selectedJokes.map((joke, index) => (
                <div key={joke.id}>
                  <div className="selected-joke-item">
                    <div className="joke-order-controls">
                      <button
                        className="move-btn"
                        onClick={() => handleMoveJoke(index, 'up')}
                        disabled={index === 0}
                        title="Move up"
                      >
                        ‚Üë
                      </button>
                      <span className="joke-number">{index + 1}</span>
                      <button
                        className="move-btn"
                        onClick={() => handleMoveJoke(index, 'down')}
                        disabled={index === selectedJokes.length - 1}
                        title="Move down"
                      >
                        ‚Üì
                      </button>
                    </div>
                    <div className="joke-content" style={{ position: 'relative' }}>
                      {renderJokePreview(joke)}
                    </div>
                    <button
                      className="remove-btn"
                      onClick={() => handleRemoveJoke(joke.id)}
                      title="Remove joke"
                    >
                      √ó
                    </button>
                  </div>
                  {/* Transition input after each joke (except the last one) */}
                  {index < selectedJokes.length - 1 && (
                    <div className="transition-section">
                      <label className="transition-label">
                        <span className="transition-label-text">Transition to next joke:</span>
                        <textarea
                          className="transition-input"
                          placeholder="How do you transition from this joke to the next? (e.g., 'Speaking of...', 'That reminds me...', etc.)"
                          value={transitions[joke.id] || ''}
                          onChange={(e) => handleTransitionChange(joke.id, e.target.value)}
                          rows={2}
                        />
                      </label>
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      <div className="editor-footer">
        <button 
          className="save-draft-btn" 
          onClick={() => handleSaveSet(true)}
        >
          üíæ Save as Draft
        </button>
        <button 
          className="finalise-btn" 
          onClick={() => handleSaveSet(false)}
        >
          ‚úÖ Finalise the Set
        </button>
      </div>
    </div>
  )
}

export default ShortSetEditor

